'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { ApiClient } from '@/lib/api-client';
import { LoadingSpinner } from '../LoadingSpinner';
import {
  Activity,
  Cpu,
  MemoryStick,
  HardDrive,
  Network,
  Zap,
  TrendingUp,
  TrendingDown,
  BarChart3,
  LineChart,
  RefreshCw,
  Settings,
  Play,
  Pause,
  Square,
  Database,
  Wifi,
  WifiOff,
  AlertTriangle,
  CheckCircle,
  Clock,
  Eye,
  EyeOff,
  Download,
  Upload,
  Users,
  Server,
  Globe,
  Shield,
  Target,
  Award,
  Star,
  Heart,
  ThumbsUp,
  MessageCircle,
  Bell,
  BellOff,
  Info,
  AlertCircle,
  XCircle,
  Plus,
  Minus,
  X,
  ChevronDown,
  ChevronUp,
  Filter,
  Search,
  Calendar,
  MoreHorizontal,
  Edit,
  Save,
  Copy,
  ExternalLink,
  Maximize,
  Minimize,
  Grid3X3,
  List,
  Layers,
  Fire,
  Sparkles,
  Lightbulb,
  Brain,
  Rocket
} from 'lucide-react';

interface MetricDataPoint {
  timestamp: number;
  value: number;
  label?: string;
}

interface MetricSeries {
  id: string;
  name: string;
  unit: string;
  color: string;
  data: MetricDataPoint[];
  current: number;
  previous: number;
  threshold?: {
    warning: number;
    critical: number;
  };
  trend: 'up' | 'down' | 'stable';
  changePercent: number;
}

interface ServerMetricStream {
  serverId: string;
  serverName: string;
  lastUpdate: number;
  connectionStatus: 'connected' | 'disconnected' | 'reconnecting' | 'error';
  metrics: {
    system: {
      cpu: MetricSeries;
      memory: MetricSeries;
      disk: MetricSeries;
      network_in: MetricSeries;
      network_out: MetricSeries;
      load: MetricSeries;
      temperature: MetricSeries;
    };
    game: {
      players: MetricSeries;
      tps: MetricSeries;
      entities: MetricSeries;
      chunks: MetricSeries;
      ping: MetricSeries;
    };
    custom: MetricSeries[];
  };
  alerts: RealtimeAlert[];
}

interface RealtimeAlert {
  id: string;
  metric: string;
  type: 'threshold' | 'anomaly' | 'spike' | 'trend';
  severity: 'info' | 'warning' | 'critical';
  message: string;
  timestamp: number;
  value: number;
  threshold?: number;
  acknowledged: boolean;
  autoGenerated: boolean;
}

interface MetricCollectorConfig {
  enabled: boolean;
  interval: number;
  retentionPeriod: number;
  bufferSize: number;
  compression: boolean;
  serverFilters: string[];
  metricFilters: string[];
  alertThresholds: Record<string, { warning: number; critical: number }>;
  anomalyDetection: boolean;
  trendAnalysis: boolean;
}

interface CollectorStats {
  totalServers: number;
  connectedServers: number;
  metricsPerSecond: number;
  totalDataPoints: number;
  memoryUsage: number;
  networkBandwidth: number;
  errors: number;
  uptime: number;
}

export function RealTimeMetricsCollector() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [streams, setStreams] = useState<ServerMetricStream[]>([]);
  const [config, setConfig] = useState<MetricCollectorConfig>({
    enabled: true,
    interval: 1000,
    retentionPeriod: 3600000, // 1 hour
    bufferSize: 1000,
    compression: true,
    serverFilters: [],
    metricFilters: ['cpu', 'memory', 'disk', 'network', 'players', 'tps'],
    alertThresholds: {
      cpu: { warning: 70, critical: 90 },
      memory: { warning: 80, critical: 95 },
      disk: { warning: 85, critical: 95 },
      network: { warning: 100, critical: 200 },
      tps: { warning: 15, critical: 10 }
    },
    anomalyDetection: true,
    trendAnalysis: true
  });
  const [stats, setStats] = useState<CollectorStats>({
    totalServers: 0,
    connectedServers: 0,
    metricsPerSecond: 0,
    totalDataPoints: 0,
    memoryUsage: 0,
    networkBandwidth: 0,
    errors: 0,
    uptime: 0
  });
  const [selectedMetrics, setSelectedMetrics] = useState<string[]>(['cpu', 'memory', 'players']);
  const [timeWindow, setTimeWindow] = useState<number>(300000); // 5 minutes
  const [showConfig, setShowConfig] = useState(false);
  const [activeAlerts, setActiveAlerts] = useState<RealtimeAlert[]>([]);
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const metricsBufferRef = useRef<Map<string, MetricDataPoint[]>>(new Map());
  const startTimeRef = useRef<number>(Date.now());

  useEffect(() => {
    if (config.enabled) {
      initializeWebSocket();
    } else {
      disconnectWebSocket();
    }

    return () => {
      disconnectWebSocket();
    };
  }, [config.enabled]);

  const initializeWebSocket = useCallback(() => {
    try {
      // Simulate WebSocket connection
      console.log('Initializing metrics WebSocket connection...');
      
      // For demo purposes, we'll simulate real-time data
      startMetricsSimulation();
      
      setError(null);
    } catch (err) {
      console.error('Failed to initialize WebSocket:', err);
      setError('Failed to connect to metrics stream');
      scheduleReconnect();
    }
  }, []);

  const disconnectWebSocket = () => {
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
  };

  const scheduleReconnect = () => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    
    reconnectTimeoutRef.current = setTimeout(() => {
      if (config.enabled) {
        console.log('Attempting to reconnect...');
        initializeWebSocket();
      }
    }, 5000);
  };

  const startMetricsSimulation = () => {
    setLoading(true);
    
    // Initialize mock streams
    const initialStreams = generateMockStreams();
    setStreams(initialStreams);
    
    // Start real-time data simulation
    const interval = setInterval(() => {
      updateMetricsData();
      updateStats();
      checkAlerts();
    }, config.interval);

    setLoading(false);

    return () => clearInterval(interval);
  };

  const generateMockStreams = (): ServerMetricStream[] => {
    const serverNames = ['Minecraft Main', 'Valheim Creative', 'Rust PvP', 'CS:GO Casual', 'ARK Survival'];
    
    return serverNames.map((name, i) => ({
      serverId: `server-${i + 1}`,
      serverName: name,
      lastUpdate: Date.now(),
      connectionStatus: Math.random() > 0.1 ? 'connected' : 'disconnected',
      metrics: {
        system: {
          cpu: createMetricSeries('cpu', 'CPU Usage', '%', '#ef4444', 50 + Math.random() * 40),
          memory: createMetricSeries('memory', 'Memory Usage', '%', '#3b82f6', 60 + Math.random() * 30),
          disk: createMetricSeries('disk', 'Disk Usage', '%', '#8b5cf6', 40 + Math.random() * 30),
          network_in: createMetricSeries('network_in', 'Network In', 'MB/s', '#10b981', Math.random() * 10),
          network_out: createMetricSeries('network_out', 'Network Out', 'MB/s', '#f59e0b', Math.random() * 5),
          load: createMetricSeries('load', 'Load Average', '', '#06b6d4', Math.random() * 4),
          temperature: createMetricSeries('temperature', 'CPU Temperature', '°C', '#f97316', 45 + Math.random() * 20)
        },
        game: {
          players: createMetricSeries('players', 'Player Count', 'players', '#84cc16', Math.floor(Math.random() * 20)),
          tps: createMetricSeries('tps', 'Ticks Per Second', 'TPS', '#ec4899', 18 + Math.random() * 2),
          entities: createMetricSeries('entities', 'Entity Count', 'entities', '#6366f1', Math.floor(Math.random() * 1000)),
          chunks: createMetricSeries('chunks', 'Loaded Chunks', 'chunks', '#14b8a6', Math.floor(Math.random() * 500)),
          ping: createMetricSeries('ping', 'Average Ping', 'ms', '#f43f5e', 20 + Math.random() * 80)
        },
        custom: []
      },
      alerts: []
    }));
  };

  const createMetricSeries = (id: string, name: string, unit: string, color: string, initialValue: number): MetricSeries => {
    const now = Date.now();
    const dataPoints: MetricDataPoint[] = [];
    
    // Generate historical data
    for (let i = 60; i >= 0; i--) {
      const timestamp = now - (i * 1000);
      const value = initialValue + (Math.random() - 0.5) * 10;
      dataPoints.push({ timestamp, value });
    }
    
    const current = dataPoints[dataPoints.length - 1]?.value || initialValue;
    const previous = dataPoints[dataPoints.length - 2]?.value || initialValue;
    const changePercent = previous !== 0 ? ((current - previous) / previous) * 100 : 0;
    
    return {
      id,
      name,
      unit,
      color,
      data: dataPoints,
      current,
      previous,
      threshold: config.alertThresholds[id],
      trend: changePercent > 1 ? 'up' : changePercent < -1 ? 'down' : 'stable',
      changePercent
    };
  };

  const updateMetricsData = () => {
    setStreams(prevStreams => 
      prevStreams.map(stream => {
        if (stream.connectionStatus !== 'connected') return stream;
        
        const now = Date.now();
        const updatedMetrics = { ...stream.metrics };
        
        // Update system metrics
        Object.keys(updatedMetrics.system).forEach(key => {
          const metric = updatedMetrics.system[key as keyof typeof updatedMetrics.system];
          const variation = (Math.random() - 0.5) * 5;
          let newValue = metric.current + variation;
          
          // Apply realistic constraints
          if (key === 'cpu' || key === 'memory' || key === 'disk') {
            newValue = Math.max(0, Math.min(100, newValue));
          } else if (key === 'temperature') {
            newValue = Math.max(30, Math.min(90, newValue));
          } else if (key.includes('network')) {
            newValue = Math.max(0, newValue);
          }
          
          const newDataPoint: MetricDataPoint = { timestamp: now, value: newValue };
          const newData = [...metric.data, newDataPoint].slice(-config.bufferSize);
          
          const previous = metric.current;
          const changePercent = previous !== 0 ? ((newValue - previous) / previous) * 100 : 0;
          
          updatedMetrics.system[key as keyof typeof updatedMetrics.system] = {
            ...metric,
            data: newData,
            current: newValue,
            previous,
            trend: changePercent > 1 ? 'up' : changePercent < -1 ? 'down' : 'stable',
            changePercent
          };
        });
        
        // Update game metrics
        Object.keys(updatedMetrics.game).forEach(key => {
          const metric = updatedMetrics.game[key as keyof typeof updatedMetrics.game];
          let variation = (Math.random() - 0.5) * 2;
          
          if (key === 'players') {
            variation = Math.floor((Math.random() - 0.5) * 3);
          } else if (key === 'tps') {
            variation = (Math.random() - 0.5) * 0.5;
          }
          
          let newValue = metric.current + variation;
          
          // Apply constraints
          if (key === 'players') {
            newValue = Math.max(0, Math.min(20, Math.floor(newValue)));
          } else if (key === 'tps') {
            newValue = Math.max(5, Math.min(20, newValue));
          } else if (key === 'ping') {
            newValue = Math.max(10, Math.min(500, newValue));
          }
          
          const newDataPoint: MetricDataPoint = { timestamp: now, value: newValue };
          const newData = [...metric.data, newDataPoint].slice(-config.bufferSize);
          
          const previous = metric.current;
          const changePercent = previous !== 0 ? ((newValue - previous) / previous) * 100 : 0;
          
          updatedMetrics.game[key as keyof typeof updatedMetrics.game] = {
            ...metric,
            data: newData,
            current: newValue,
            previous,
            trend: changePercent > 1 ? 'up' : changePercent < -1 ? 'down' : 'stable',
            changePercent
          };
        });
        
        return {
          ...stream,
          lastUpdate: now,
          metrics: updatedMetrics
        };
      })
    );
  };

  const updateStats = () => {
    const now = Date.now();
    const uptime = now - startTimeRef.current;
    
    setStats(prevStats => {
      const connectedServers = streams.filter(s => s.connectionStatus === 'connected').length;
      const totalDataPoints = streams.reduce((sum, stream) => {
        return sum + Object.values(stream.metrics.system).reduce((metricSum, metric) => metricSum + metric.data.length, 0);
      }, 0);
      
      return {
        totalServers: streams.length,
        connectedServers,
        metricsPerSecond: Math.floor(totalDataPoints / (uptime / 1000)),
        totalDataPoints,
        memoryUsage: Math.floor(totalDataPoints * 0.001), // Simulate memory usage
        networkBandwidth: Math.floor(Math.random() * 50 + 10),
        errors: prevStats.errors + (Math.random() > 0.99 ? 1 : 0),
        uptime
      };
    });
  };

  const checkAlerts = () => {
    const newAlerts: RealtimeAlert[] = [];
    
    streams.forEach(stream => {
      if (stream.connectionStatus !== 'connected') return;
      
      // Check system metrics against thresholds
      Object.entries(stream.metrics.system).forEach(([key, metric]) => {
        if (!metric.threshold) return;
        
        const { warning, critical } = metric.threshold;
        const value = metric.current;
        
        if (value > critical) {
          newAlerts.push({
            id: `${stream.serverId}-${key}-critical-${Date.now()}`,
            metric: key,
            type: 'threshold',
            severity: 'critical',
            message: `${metric.name} is critically high at ${value.toFixed(1)}${metric.unit}`,
            timestamp: Date.now(),
            value,
            threshold: critical,
            acknowledged: false,
            autoGenerated: true
          });
        } else if (value > warning) {
          newAlerts.push({
            id: `${stream.serverId}-${key}-warning-${Date.now()}`,
            metric: key,
            type: 'threshold',
            severity: 'warning',
            message: `${metric.name} is above warning threshold at ${value.toFixed(1)}${metric.unit}`,
            timestamp: Date.now(),
            value,
            threshold: warning,
            acknowledged: false,
            autoGenerated: true
          });
        }
      });
      
      // Check for anomalies and trends
      if (config.anomalyDetection) {
        Object.entries(stream.metrics.system).forEach(([key, metric]) => {
          if (Math.abs(metric.changePercent) > 50) {
            newAlerts.push({
              id: `${stream.serverId}-${key}-anomaly-${Date.now()}`,
              metric: key,
              type: 'anomaly',
              severity: 'warning',
              message: `Unusual ${metric.changePercent > 0 ? 'spike' : 'drop'} in ${metric.name} (${metric.changePercent.toFixed(1)}%)`,
              timestamp: Date.now(),
              value: metric.current,
              acknowledged: false,
              autoGenerated: true
            });
          }
        });
      }
    });
    
    // Update active alerts (remove old ones, add new ones)
    setActiveAlerts(prevAlerts => {
      const filtered = prevAlerts.filter(alert => Date.now() - alert.timestamp < 300000); // Keep for 5 minutes
      return [...filtered, ...newAlerts];
    });
  };

  const acknowledgeAlert = (alertId: string) => {
    setActiveAlerts(prev => 
      prev.map(alert => 
        alert.id === alertId ? { ...alert, acknowledged: true } : alert
      )
    );
  };

  const getMetricIcon = (metricId: string) => {
    switch (metricId) {
      case 'cpu': return Cpu;
      case 'memory': return MemoryStick;
      case 'disk': return HardDrive;
      case 'network_in':
      case 'network_out': return Network;
      case 'load': return Activity;
      case 'temperature': return Zap;
      case 'players': return Users;
      case 'tps': return Target;
      case 'entities': return Globe;
      case 'chunks': return Grid3X3;
      case 'ping': return Wifi;
      default: return BarChart3;
    }
  };

  const getTrendIcon = (trend: string) => {
    switch (trend) {
      case 'up': return TrendingUp;
      case 'down': return TrendingDown;
      default: return Activity;
    }
  };

  const getTrendColor = (trend: string, changePercent: number) => {
    if (trend === 'stable') return 'text-gray-500';
    if (Math.abs(changePercent) > 20) return 'text-red-500';
    return trend === 'up' ? 'text-green-500' : 'text-blue-500';
  };

  const formatUptime = (ms: number) => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ${hours % 24}h`;
    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    return `${minutes}m ${seconds % 60}s`;
  };

  const toggleCollector = () => {
    setConfig(prev => ({ ...prev, enabled: !prev.enabled }));
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-96">
        <LoadingSpinner />
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <div className="flex items-center space-x-2">
          <AlertCircle className="h-5 w-5 text-red-500" />
          <span className="text-red-700">{error}</span>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-gray-900">Real-Time Metrics Collector</h2>
          <p className="text-gray-600">Live streaming metrics from all connected servers</p>
        </div>
        <div className="flex items-center space-x-3">
          <button
            onClick={toggleCollector}
            className={`inline-flex items-center px-4 py-2 rounded-lg font-medium transition-colors ${
              config.enabled
                ? 'bg-green-100 text-green-700 hover:bg-green-200'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            {config.enabled ? <Pause className="h-4 w-4 mr-2" /> : <Play className="h-4 w-4 mr-2" />}
            {config.enabled ? 'Pause' : 'Start'} Collection
          </button>
          <button
            onClick={() => setShowConfig(true)}
            className="inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            <Settings className="h-4 w-4 mr-2" />
            Configure
          </button>
        </div>
      </div>

      {/* Collector Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <div className="bg-white border border-gray-200 rounded-lg p-4">
          <div className="flex items-center">
            <Server className="h-8 w-8 text-blue-600" />
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">Connected Servers</p>
              <p className="text-2xl font-bold text-gray-900">
                {stats.connectedServers}/{stats.totalServers}
              </p>
            </div>
          </div>
        </div>
        <div className="bg-white border border-gray-200 rounded-lg p-4">
          <div className="flex items-center">
            <Activity className="h-8 w-8 text-green-600" />
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">Metrics/Second</p>
              <p className="text-2xl font-bold text-gray-900">{stats.metricsPerSecond}</p>
            </div>
          </div>
        </div>
        <div className="bg-white border border-gray-200 rounded-lg p-4">
          <div className="flex items-center">
            <Database className="h-8 w-8 text-purple-600" />
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">Data Points</p>
              <p className="text-2xl font-bold text-gray-900">{stats.totalDataPoints.toLocaleString()}</p>
            </div>
          </div>
        </div>
        <div className="bg-white border border-gray-200 rounded-lg p-4">
          <div className="flex items-center">
            <Clock className="h-8 w-8 text-orange-600" />
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">Uptime</p>
              <p className="text-2xl font-bold text-gray-900">{formatUptime(stats.uptime)}</p>
            </div>
          </div>
        </div>
      </div>

      {/* Active Alerts */}
      {activeAlerts.filter(a => !a.acknowledged).length > 0 && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <div className="flex items-center justify-between mb-3">
            <h3 className="text-lg font-semibold text-yellow-800">Active Alerts</h3>
            <span className="text-sm text-yellow-600">
              {activeAlerts.filter(a => !a.acknowledged).length} unacknowledged
            </span>
          </div>
          <div className="space-y-2">
            {activeAlerts.filter(a => !a.acknowledged).slice(0, 5).map(alert => (
              <div key={alert.id} className={`flex items-center justify-between p-2 rounded border ${
                alert.severity === 'critical' ? 'bg-red-50 border-red-200' :
                alert.severity === 'warning' ? 'bg-yellow-50 border-yellow-200' :
                'bg-blue-50 border-blue-200'
              }`}>
                <div className="flex-1">
                  <p className="text-sm font-medium text-gray-900">{alert.message}</p>
                  <p className="text-xs text-gray-500">
                    {new Date(alert.timestamp).toLocaleTimeString()} • {alert.type}
                  </p>
                </div>
                <button
                  onClick={() => acknowledgeAlert(alert.id)}
                  className="ml-2 px-2 py-1 text-xs bg-gray-600 text-white rounded hover:bg-gray-700"
                >
                  Ack
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Metric Selection */}
      <div className="bg-white border border-gray-200 rounded-lg p-4">
        <h3 className="text-lg font-semibold text-gray-900 mb-3">Displayed Metrics</h3>
        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-3">
          {config.metricFilters.map(metricId => {
            const Icon = getMetricIcon(metricId);
            const isSelected = selectedMetrics.includes(metricId);
            
            return (
              <button
                key={metricId}
                onClick={() => {
                  if (isSelected) {
                    setSelectedMetrics(prev => prev.filter(m => m !== metricId));
                  } else {
                    setSelectedMetrics(prev => [...prev, metricId]);
                  }
                }}
                className={`flex items-center space-x-2 p-2 rounded-lg border transition-colors ${
                  isSelected
                    ? 'bg-blue-100 border-blue-300 text-blue-700'
                    : 'bg-gray-50 border-gray-200 text-gray-600 hover:bg-gray-100'
                }`}
              >
                <Icon className="h-4 w-4" />
                <span className="text-sm font-medium capitalize">{metricId.replace('_', ' ')}</span>
              </button>
            );
          })}
        </div>
      </div>

      {/* Live Metrics Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {streams.filter(stream => stream.connectionStatus === 'connected').map(stream => (
          <div key={stream.serverId} className="bg-white border border-gray-200 rounded-lg p-6">
            <div className="flex items-center justify-between mb-4">
              <h3 className="font-semibold text-gray-900">{stream.serverName}</h3>
              <div className="flex items-center space-x-2">
                <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                <span className="text-xs text-gray-500">Live</span>
              </div>
            </div>
            
            <div className="space-y-4">
              {selectedMetrics.map(metricId => {
                const metric = stream.metrics.system[metricId as keyof typeof stream.metrics.system] || 
                              stream.metrics.game[metricId as keyof typeof stream.metrics.game];
                
                if (!metric) return null;
                
                const Icon = getMetricIcon(metricId);
                const TrendIcon = getTrendIcon(metric.trend);
                const trendColor = getTrendColor(metric.trend, metric.changePercent);
                
                return (
                  <div key={metricId} className="flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                      <Icon className="h-5 w-5 text-gray-600" />
                      <div>
                        <p className="text-sm font-medium text-gray-900">{metric.name}</p>
                        <div className="flex items-center space-x-2">
                          <span className="text-lg font-bold text-gray-900">
                            {metric.current.toFixed(1)}{metric.unit}
                          </span>
                          <div className={`flex items-center space-x-1 ${trendColor}`}>
                            <TrendIcon className="h-3 w-3" />
                            <span className="text-xs">
                              {Math.abs(metric.changePercent).toFixed(1)}%
                            </span>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    {/* Mini chart */}
                    <div className="w-16 h-8">
                      <svg viewBox="0 0 64 32" className="w-full h-full">
                        <polyline
                          fill="none"
                          stroke={metric.color}
                          strokeWidth="1"
                          points={metric.data.slice(-20).map((point, i) => {
                            const x = (i / 19) * 64;
                            const y = 32 - ((point.value / 100) * 32);
                            return `${x},${y}`;
                          }).join(' ')}
                        />
                      </svg>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ))}
      </div>

      {/* Disconnected Servers */}
      {streams.filter(stream => stream.connectionStatus !== 'connected').length > 0 && (
        <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
          <h3 className="text-lg font-semibold text-gray-900 mb-3">Disconnected Servers</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {streams.filter(stream => stream.connectionStatus !== 'connected').map(stream => (
              <div key={stream.serverId} className="flex items-center justify-between p-3 bg-white rounded border">
                <div className="flex items-center space-x-3">
                  <WifiOff className="h-5 w-5 text-red-500" />
                  <div>
                    <p className="font-medium text-gray-900">{stream.serverName}</p>
                    <p className="text-sm text-gray-500">{stream.connectionStatus}</p>
                  </div>
                </div>
                <button
                  onClick={() => {
                    setStreams(prev => 
                      prev.map(s => 
                        s.serverId === stream.serverId 
                          ? { ...s, connectionStatus: 'reconnecting' }
                          : s
                      )
                    );
                    
                    setTimeout(() => {
                      setStreams(prev => 
                        prev.map(s => 
                          s.serverId === stream.serverId 
                            ? { ...s, connectionStatus: 'connected' }
                            : s
                        )
                      );
                    }, 2000);
                  }}
                  className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                  Reconnect
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Configuration Modal */}
      {showConfig && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
            <div className="p-6">
              <div className="flex items-center justify-between mb-6">
                <h3 className="text-lg font-semibold text-gray-900">Metrics Collector Configuration</h3>
                <button
                  onClick={() => setShowConfig(false)}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="h-6 w-6" />
                </button>
              </div>

              <div className="space-y-6">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Collection Interval (ms)
                  </label>
                  <input
                    type="number"
                    value={config.interval}
                    onChange={(e) => setConfig(prev => ({ ...prev, interval: parseInt(e.target.value) || 1000 }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Buffer Size (data points)
                  </label>
                  <input
                    type="number"
                    value={config.bufferSize}
                    onChange={(e) => setConfig(prev => ({ ...prev, bufferSize: parseInt(e.target.value) || 1000 }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="flex items-center space-x-2">
                      <input
                        type="checkbox"
                        checked={config.anomalyDetection}
                        onChange={(e) => setConfig(prev => ({ ...prev, anomalyDetection: e.target.checked }))}
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                      />
                      <span className="text-sm font-medium text-gray-700">Anomaly Detection</span>
                    </label>
                  </div>
                  <div>
                    <label className="flex items-center space-x-2">
                      <input
                        type="checkbox"
                        checked={config.trendAnalysis}
                        onChange={(e) => setConfig(prev => ({ ...prev, trendAnalysis: e.target.checked }))}
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                      />
                      <span className="text-sm font-medium text-gray-700">Trend Analysis</span>
                    </label>
                  </div>
                </div>

                <div>
                  <h4 className="text-sm font-medium text-gray-700 mb-3">Alert Thresholds</h4>
                  <div className="space-y-3">
                    {Object.entries(config.alertThresholds).map(([metric, thresholds]) => (
                      <div key={metric} className="grid grid-cols-3 gap-3 items-center">
                        <span className="text-sm text-gray-600 capitalize">{metric.replace('_', ' ')}</span>
                        <div>
                          <label className="text-xs text-gray-500">Warning</label>
                          <input
                            type="number"
                            value={thresholds.warning}
                            onChange={(e) => setConfig(prev => ({
                              ...prev,
                              alertThresholds: {
                                ...prev.alertThresholds,
                                [metric]: {
                                  ...prev.alertThresholds[metric],
                                  warning: parseInt(e.target.value) || 0
                                }
                              }
                            }))}
                            className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-1 focus:ring-blue-500"
                          />
                        </div>
                        <div>
                          <label className="text-xs text-gray-500">Critical</label>
                          <input
                            type="number"
                            value={thresholds.critical}
                            onChange={(e) => setConfig(prev => ({
                              ...prev,
                              alertThresholds: {
                                ...prev.alertThresholds,
                                [metric]: {
                                  ...prev.alertThresholds[metric],
                                  critical: parseInt(e.target.value) || 0
                                }
                              }
                            }))}
                            className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-1 focus:ring-blue-500"
                          />
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              <div className="flex justify-end space-x-3 mt-6">
                <button
                  onClick={() => setShowConfig(false)}
                  className="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200"
                >
                  Cancel
                </button>
                <button
                  onClick={() => setShowConfig(false)}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  Save Configuration
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}