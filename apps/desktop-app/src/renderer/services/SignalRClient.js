const { io } = require('socket.io-client');
const { EventEmitter } = require('events');

/**
 * SignalR Client Service - Real-time communication with desktop SignalR server
 * 
 * Provides real-time updates for server status, logs, metrics, and community activity.
 * Handles automatic reconnection, authentication, and event management.
 */
class SignalRClient extends EventEmitter {
  constructor() {
    super();
    this.socket = null;
    this.isConnected = false;
    this.isAuthenticated = false;
    this.connectionAttempts = 0;
    this.maxReconnectAttempts = 10;
    this.reconnectDelay = 1000; // Start with 1 second
    this.maxReconnectDelay = 30000; // Max 30 seconds
    this.heartbeatInterval = null;
    this.reconnectTimeout = null;
    
    // Connection configuration
    this.serverUrl = 'http://localhost:3456';
    this.clientInfo = {
      deviceName: this.getDeviceName(),
      deviceType: 'web_client',
      userAgent: navigator.userAgent,
      timestamp: new Date().toISOString()
    };
    
    // Event subscriptions
    this.subscriptions = new Set();
    this.logSubscriptions = new Set();
    
    // Performance tracking
    this.metrics = {
      messagesReceived: 0,
      messagesSent: 0,
      connectionStartTime: null,
      lastMessageTime: null,
      averageLatency: 0,
      latencyMeasurements: []
    };
  }

  /**
   * Initialize and connect to SignalR server
   */
  async initialize() {
    try {
      console.log('üîÑ Initializing SignalR client...');\n      
      // Get connection info from main process
      const connectionInfo = await window.electronAPI.invoke('signalr-get-connection-info');\n      
      if (connectionInfo?.port) {\n        this.serverUrl = `http://localhost:${connectionInfo.port}`;\n      }\n      \n      await this.connect();\n      console.log('‚úÖ SignalR client initialized successfully');\n    } catch (error) {\n      console.error('‚ùå Failed to initialize SignalR client:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Connect to SignalR server\n   */\n  async connect() {\n    try {\n      if (this.socket) {\n        this.disconnect();\n      }\n\n      console.log(`üîå Connecting to SignalR server at ${this.serverUrl}...`);\n      this.metrics.connectionStartTime = Date.now();\n      \n      this.socket = io(this.serverUrl, {\n        transports: ['websocket', 'polling'],\n        timeout: 10000,\n        reconnection: false, // We'll handle reconnection manually\n        forceNew: true\n      });\n\n      this.setupEventHandlers();\n      \n      // Wait for connection\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Connection timeout'));\n        }, 10000);\n\n        this.socket.once('connect', () => {\n          clearTimeout(timeout);\n          this.isConnected = true;\n          this.connectionAttempts = 0;\n          this.reconnectDelay = 1000;\n          console.log('‚úÖ Connected to SignalR server');\n          resolve();\n        });\n\n        this.socket.once('connect_error', (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n      });\n\n      // Authenticate with the server\n      await this.authenticate();\n      \n      // Start heartbeat\n      this.startHeartbeat();\n      \n      this.emit('connected');\n    } catch (error) {\n      console.error('‚ùå Failed to connect to SignalR server:', error);\n      this.handleConnectionError(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate with SignalR server using pairing code\n   */\n  async authenticate() {\n    try {\n      // First, get a pairing code from the server\n      const pairingResponse = await fetch(`${this.serverUrl}/pair`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          deviceName: this.clientInfo.deviceName,\n          deviceType: this.clientInfo.deviceType\n        })\n      });\n\n      if (!pairingResponse.ok) {\n        throw new Error('Failed to get pairing code');\n      }\n\n      const { pairingCode } = await pairingResponse.json();\n      console.log(`üîê Got pairing code: ${pairingCode}`);\n\n      // Authenticate with the socket\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Authentication timeout'));\n        }, 5000);\n\n        this.socket.once('auth-success', (data) => {\n          clearTimeout(timeout);\n          this.isAuthenticated = true;\n          console.log('‚úÖ Authentication successful:', data);\n          this.emit('authenticated', data);\n          resolve(data);\n        });\n\n        this.socket.once('auth-failed', (error) => {\n          clearTimeout(timeout);\n          console.error('‚ùå Authentication failed:', error);\n          reject(new Error(error.error || 'Authentication failed'));\n        });\n\n        this.socket.emit('authenticate', {\n          pairingCode,\n          deviceInfo: this.clientInfo\n        });\n      });\n    } catch (error) {\n      console.error('‚ùå Authentication error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Set up socket event handlers\n   */\n  setupEventHandlers() {\n    if (!this.socket) return;\n\n    // Connection events\n    this.socket.on('connect', () => {\n      console.log('üîå Socket connected');\n      this.isConnected = true;\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      console.log('üîå Socket disconnected:', reason);\n      this.isConnected = false;\n      this.isAuthenticated = false;\n      this.stopHeartbeat();\n      this.emit('disconnected', reason);\n      \n      // Attempt reconnection if not a manual disconnect\n      if (reason !== 'io client disconnect') {\n        this.scheduleReconnection();\n      }\n    });\n\n    this.socket.on('connect_error', (error) => {\n      console.error('üîå Connection error:', error);\n      this.handleConnectionError(error);\n    });\n\n    // Server status updates\n    this.socket.on('server-status-update', (data) => {\n      this.updateMetrics();\n      this.emit('server-status-update', data);\n    });\n\n    // Server metrics updates\n    this.socket.on('server-metrics-update', (data) => {\n      this.updateMetrics();\n      this.emit('server-metrics-update', data);\n    });\n\n    // Performance alerts\n    this.socket.on('performance-alert', (data) => {\n      this.updateMetrics();\n      this.emit('performance-alert', data);\n    });\n\n    // Server logs\n    this.socket.on('server-log', (data) => {\n      this.updateMetrics();\n      this.emit('server-log', data);\n    });\n\n    // Command responses\n    this.socket.on('command-response', (data) => {\n      this.updateMetrics();\n      this.emit('command-response', data);\n    });\n\n    // Error handling\n    this.socket.on('command-error', (error) => {\n      console.error('üîß Command error:', error);\n      this.emit('command-error', error);\n    });\n\n    this.socket.on('subscription-error', (error) => {\n      console.error('üì° Subscription error:', error);\n      this.emit('subscription-error', error);\n    });\n\n    // Server shutdown notification\n    this.socket.on('server-shutdown', (data) => {\n      console.log('üõë Server shutdown notification:', data);\n      this.emit('server-shutdown', data);\n    });\n  }\n\n  /**\n   * Send server command to desktop application\n   */\n  async sendServerCommand(command, serverId, params = {}) {\n    if (!this.isAuthenticated) {\n      throw new Error('Not authenticated with SignalR server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Command timeout'));\n      }, 30000); // 30 second timeout\n\n      const responseHandler = (data) => {\n        if (data.command === command && data.serverId === serverId) {\n          clearTimeout(timeout);\n          this.socket.off('command-response', responseHandler);\n          resolve(data.response);\n        }\n      };\n\n      this.socket.on('command-response', responseHandler);\n      \n      this.socket.emit('server-command', {\n        command,\n        serverId,\n        params\n      });\n      \n      this.updateMetrics(true);\n    });\n  }\n\n  /**\n   * Subscribe to server logs\n   */\n  subscribeToServerLogs(serverId) {\n    if (!this.isAuthenticated) {\n      console.warn('Cannot subscribe to logs: not authenticated');\n      return;\n    }\n\n    if (this.logSubscriptions.has(serverId)) {\n      console.log(`Already subscribed to logs for server: ${serverId}`);\n      return;\n    }\n\n    this.socket.emit('subscribe-logs', { serverId });\n    this.logSubscriptions.add(serverId);\n    console.log(`üìú Subscribed to logs for server: ${serverId}`);\n  }\n\n  /**\n   * Unsubscribe from server logs\n   */\n  unsubscribeFromServerLogs(serverId) {\n    if (!this.socket) return;\n\n    this.socket.emit('unsubscribe-logs', { serverId });\n    this.logSubscriptions.delete(serverId);\n    console.log(`üìú Unsubscribed from logs for server: ${serverId}`);\n  }\n\n  /**\n   * Request current server status\n   */\n  requestServerStatus() {\n    if (!this.isAuthenticated) {\n      console.warn('Cannot request server status: not authenticated');\n      return;\n    }\n\n    this.socket.emit('get-server-status');\n    this.updateMetrics(true);\n  }\n\n  /**\n   * Handle connection errors and implement exponential backoff\n   */\n  handleConnectionError(error) {\n    this.connectionAttempts++;\n    console.error(`‚ùå Connection attempt ${this.connectionAttempts} failed:`, error.message);\n    \n    this.emit('connection-error', {\n      error,\n      attempt: this.connectionAttempts,\n      maxAttempts: this.maxReconnectAttempts\n    });\n\n    if (this.connectionAttempts < this.maxReconnectAttempts) {\n      this.scheduleReconnection();\n    } else {\n      console.error('‚ùå Max reconnection attempts reached. Giving up.');\n      this.emit('connection-failed', { error, attempts: this.connectionAttempts });\n    }\n  }\n\n  /**\n   * Schedule reconnection with exponential backoff\n   */\n  scheduleReconnection() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n\n    const delay = Math.min(this.reconnectDelay * Math.pow(2, this.connectionAttempts - 1), this.maxReconnectDelay);\n    console.log(`üîÑ Scheduling reconnection in ${delay}ms...`);\n    \n    this.reconnectTimeout = setTimeout(() => {\n      console.log('üîÑ Attempting to reconnect...');\n      this.connect().catch(error => {\n        console.error('üîÑ Reconnection failed:', error);\n      });\n    }, delay);\n  }\n\n  /**\n   * Start heartbeat to maintain connection\n   */\n  startHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n\n    this.heartbeatInterval = setInterval(() => {\n      if (this.isConnected && this.socket) {\n        const startTime = Date.now();\n        this.socket.emit('ping', startTime);\n        \n        this.socket.once('pong', (timestamp) => {\n          const latency = Date.now() - timestamp;\n          this.updateLatency(latency);\n        });\n      }\n    }, 30000); // Heartbeat every 30 seconds\n  }\n\n  /**\n   * Stop heartbeat\n   */\n  stopHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n\n  /**\n   * Update connection metrics\n   */\n  updateMetrics(sent = false) {\n    this.metrics.lastMessageTime = Date.now();\n    \n    if (sent) {\n      this.metrics.messagesSent++;\n    } else {\n      this.metrics.messagesReceived++;\n    }\n  }\n\n  /**\n   * Update latency measurements\n   */\n  updateLatency(latency) {\n    this.metrics.latencyMeasurements.push(latency);\n    \n    // Keep only last 10 measurements\n    if (this.metrics.latencyMeasurements.length > 10) {\n      this.metrics.latencyMeasurements.shift();\n    }\n    \n    // Calculate average latency\n    this.metrics.averageLatency = this.metrics.latencyMeasurements.reduce((sum, val) => sum + val, 0) / this.metrics.latencyMeasurements.length;\n  }\n\n  /**\n   * Get device name\n   */\n  getDeviceName() {\n    return `Web Client - ${navigator.platform || 'Unknown'}`;\n  }\n\n  /**\n   * Get connection status\n   */\n  getConnectionStatus() {\n    return {\n      isConnected: this.isConnected,\n      isAuthenticated: this.isAuthenticated,\n      connectionAttempts: this.connectionAttempts,\n      serverUrl: this.serverUrl,\n      uptime: this.metrics.connectionStartTime ? Date.now() - this.metrics.connectionStartTime : 0,\n      metrics: { ...this.metrics },\n      subscriptions: {\n        logs: Array.from(this.logSubscriptions)\n      }\n    };\n  }\n\n  /**\n   * Disconnect from SignalR server\n   */\n  disconnect() {\n    console.log('üîå Disconnecting from SignalR server...');\n    \n    this.stopHeartbeat();\n    \n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    this.isConnected = false;\n    this.isAuthenticated = false;\n    this.connectionAttempts = 0;\n    this.logSubscriptions.clear();\n    \n    console.log('‚úÖ Disconnected from SignalR server');\n    this.emit('disconnected', 'manual');\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy() {\n    this.disconnect();\n    this.removeAllListeners();\n  }\n}\n\n// Export singleton instance\nconst signalRClient = new SignalRClient();\nmodule.exports = signalRClient;